// Generated by CoffeeScript 1.4.0
var ContentStack, Emblem, Handlebars, processNodes,
  __hasProp = {}.hasOwnProperty;

Handlebars = require('handlebars');

Emblem = require('./emblem');

ContentStack = (function() {

  function ContentStack() {
    this.current = "";
  }

  ContentStack.prototype.append = function(s) {
    return this.current += s;
  };

  ContentStack.prototype.flatten = function() {
    var ret;
    ret = this.current;
    this.current = "";
    return ret;
  };

  return ContentStack;

})();

processNodes = function(nodes, stack, statements) {
  var attributesString, c, classNames, classes, closeId, firstChar, hash, helper, id, ids, k, name, node, openStache, pairs, param, params, result, substatements, tagName, v, value, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
  if (statements == null) {
    statements = [];
  }
  for (_i = 0, _len = nodes.length; _i < _len; _i++) {
    node = nodes[_i];
    if (node.type === 'html') {
      tagName = node.tagName || 'div';
      classes = node.attrs.classes || [];
      classNames = classes.join(' ');
      attributesString = "";
      _ref = node.attrs || {};
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        value = _ref[name];
        attributesString += ' ' + name + '=' + '"' + value + '"';
      }
      stack.append("<" + tagName + attributesString + ">");
      processNodes(node.nodes || [], stack, statements);
      stack.append("</" + tagName + ">");
    } else if (node.type === 'mustache') {
      c = stack.flatten();
      if (c) {
        statements.push(new Handlebars.AST.ContentNode(c));
      }
      firstChar = node.params[0].charAt(0);
      if (!node.forced && firstChar === firstChar.toUpperCase()) {
        helper = "view";
        node.params.unshift(helper);
      }
      params = [];
      _ref1 = node.params;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        param = _ref1[_j];
        ids = param.split('.');
        result = [];
        for (_k = 0, _len2 = ids.length; _k < _len2; _k++) {
          id = ids[_k];
          result.push(id);
          result.push('.');
        }
        result.pop();
        params.push(new Handlebars.AST.IdNode(result));
      }
      pairs = [];
      _ref2 = node.hash;
      for (k in _ref2) {
        if (!__hasProp.call(_ref2, k)) continue;
        v = _ref2[k];
        pairs.push([k, v]);
      }
      hash = null;
      if (pairs.length) {
        hash = new Handlebars.AST.HashNode(pairs);
      }
      if (node.nodes && node.nodes.length) {
        closeId = params[0];
        substatements = processNodes(node.nodes, new ContentStack);
        statements.push(new Handlebars.AST.ProgramNode(substatements, []));
        openStache = new Handlebars.AST.MustacheNode(params, hash, node.escaped);
        statements.push(new Handlebars.AST.BlockNode(openStache, statements, [], closeId));
      } else {
        statements.push(new Handlebars.AST.MustacheNode(params, hash, node.escaped));
      }
    } else if (node instanceof Array) {
      processNodes(node, stack, statements);
    } else {
      stack.append(node.toString());
    }
  }
  return statements;
};

Emblem.parse = function(string) {
  var c, emblemAST, processed, stack, statements;
  stack = new ContentStack;
  processed = Emblem.Preprocessor.processSync(string);
  emblemAST = Emblem.Parser.parse(processed);
  statements = processNodes(emblemAST, stack);
  c = stack.flatten();
  if (c) {
    statements.push(new Handlebars.AST.ContentNode(c));
  }
  return new Handlebars.AST.ProgramNode(statements, []);
};

// Generated by CoffeeScript 1.4.0
var CompilerContext, Emblem, Handlebars, assert, compileWithPartials, equal, equals, ok, shouldCompileTo, shouldCompileToWithPartials, shouldThrow, throws, _equal;

if (!((typeof Handlebars !== "undefined" && Handlebars !== null) && (typeof Emblem !== "undefined" && Emblem !== null))) {
  Emblem = require('../lib/emblem');
  Handlebars = require('handlebars');
  assert = require("assert");
  equal = assert.equal, equals = assert.equals, ok = assert.ok, throws = assert.throws;
} else {
  _equal = equal;
  equals = equal = function(a, b, msg) {
    return _equal(a, b, msg || '');
  };
}

if (typeof CompilerContext === "undefined" || CompilerContext === null) {
  CompilerContext = {
    compile: function(template, options) {
      var templateSpec;
      templateSpec = Emblem.precompile(template, options);
      return Handlebars.template(eval("(" + templateSpec + ")"));
    }
  };
}

shouldCompileTo = function(string, hashOrArray, expected, message) {
  if (hashOrArray.constructor === String) {
    return shouldCompileToWithPartials(string, {}, false, hashOrArray, message);
  } else {
    return shouldCompileToWithPartials(string, hashOrArray, false, expected, message);
  }
};

shouldCompileToWithPartials = function(string, hashOrArray, partials, expected, message) {
  var result;
  result = compileWithPartials(string, hashOrArray, partials);
  return equal(result, expected, "'" + expected + "' should === '" + result + "': " + message);
};

compileWithPartials = function(string, hashOrArray, partials) {
  var ary, helpers, prop, template;
  template = CompilerContext.compile(string);
  if (Object.prototype.toString.call(hashOrArray) === "[object Array]") {
    if (helpers = hashOrArray[1]) {
      for (prop in Handlebars.helpers) {
        helpers[prop] = helpers[prop] || Handlebars.helpers[prop];
      }
    }
    ary = [];
    ary.push(hashOrArray[0]);
    ary.push({
      helpers: hashOrArray[1],
      partials: hashOrArray[2]
    });
  } else {
    ary = [hashOrArray];
  }
  return template.apply(this, ary);
};

shouldThrow = function(fn, exception, message) {
  var caught, exMessage, exType;
  caught = false;
  if (exception instanceof Array) {
    exType = exception[0];
    exMessage = exception[1];
  } else if (typeof exception === 'string') {
    exType = Error;
    exMessage = exception;
  } else {
    exType = exception;
  }
  try {
    fn();
  } catch (e) {
    if (!exType) {
      caught = true;
    } else {
      if (e instanceof exType) {
        if (!exMessage || e.message === exMessage) {
          caught = true;
        }
      }
    }
  }
  return ok(caught, message || null);
};

suite("html one-liners");

test("element only", function() {
  return shouldCompileTo("p", "<p></p>");
});

test("with text", function() {
  return shouldCompileTo("p Hello", "<p>Hello</p>");
});

test("with more complex text", function() {
  return shouldCompileTo("p Hello, how's it going with you today?", "<p>Hello, how's it going with you today?</p>");
});

test("with trailing space", function() {
  return shouldCompileTo("p Hello   ", "<p>Hello   </p>");
});

suite("text lines");

test("basic", function() {
  return shouldCompileTo("| What what", "What what");
});

test("with html", function() {
  return shouldCompileTo('| What <span id="woot" data-t="oof" class="f">what</span>!', 'What <span id="woot" data-t="oof" class="f">what</span>!');
});

test("multiline", function() {
  var emblem;
  emblem = "| Blork\n  Snork";
  return shouldCompileTo(emblem, "BlorkSnork");
});

test("multiline w/ trailing whitespace", function() {
  var emblem;
  emblem = "| Blork \n  Snork";
  return shouldCompileTo(emblem, "Blork Snork");
});

test("multiline with empty first line", function() {
  var emblem;
  emblem = "| \n  Good";
  return shouldCompileTo(emblem, "Good");
});

suite("preprocessor");

test("it strips out preceding whitespace", function() {
  var emblem;
  emblem = "\np Hello";
  return shouldCompileTo(emblem, "<p>Hello</p>");
});

test("it handles preceding indentation", function() {
  var emblem;
  emblem = "  p Woot\n  p Ha";
  return shouldCompileTo(emblem, "<p>Woot</p><p>Ha</p>");
});

test("it handles preceding indentation and newlines", function() {
  var emblem;
  emblem = "\n  p Woot\n  p Ha";
  return shouldCompileTo(emblem, "<p>Woot</p><p>Ha</p>");
});

test("it handles preceding indentation and newlines pt 2", function() {
  var emblem;
  emblem = "  \n  p Woot\n  p Ha";
  return shouldCompileTo(emblem, "<p>Woot</p><p>Ha</p>");
});

test("it strips out single line '/' comments", function() {
  var emblem;
  emblem = "p Hello\n\n/ A comment\n\nh1 How are you?";
  return shouldCompileTo(emblem, "<p>Hello</p><h1>How are you?</h1>");
});

test("it strips out multi-line '/' comments", function() {
  var emblem;
  emblem = "p Hello\n\n/ A comment\n  that goes on to two lines\n  even three!\n\nh1 How are you?";
  return shouldCompileTo(emblem, "<p>Hello</p><h1>How are you?</h1>");
});

test("it strips out multi-line '/' comments without text on the first line", function() {
  var emblem;
  emblem = "p Hello\n\n/ \n  A comment\n  that goes on to two lines\n  even three!\n\nh1 How are you?";
  return shouldCompileTo(emblem, "<p>Hello</p><h1>How are you?</h1>");
});

suite("indentation");

test("it throws when indenting after a line with inline content", function() {
  var emblem;
  emblem = "p Hello\n  p invalid";
  return shouldThrow(function() {
    return CompilerContext.compile(emblem);
  });
});

test("it throws on half dedent", function() {
  var emblem;
  emblem = "p\n    span This is ok\n  span This aint";
  return shouldThrow(function() {
    return CompilerContext.compile(emblem);
  });
});

suite("attribute shorthand");

test("id shorthand", function() {
  shouldCompileTo("#woot", '<div id="woot"></div>');
  return shouldCompileTo("span#woot", '<span id="woot"></span>');
});

test("class shorthand", function() {
  shouldCompileTo(".woot", '<div class="woot"></div>');
  shouldCompileTo("span.woot", '<span class="woot"></span>');
  return shouldCompileTo("span.woot.loot", '<span class="woot loot"></span>');
});

suite("full attributes");

test("tags without content", function() {
  shouldCompileTo('p class="yes"', '<p class="yes"></p>');
  shouldCompileTo('p id="yes"', '<p id="yes"></p>');
  return shouldCompileTo('p id="yes" class="no"', '<p id="yes" class="no"></p>');
});

test("tags with content", function() {
  shouldCompileTo('p class="yes" Blork', '<p class="yes">Blork</p>');
  shouldCompileTo('p id="yes" Hyeah', '<p id="yes">Hyeah</p>');
  shouldCompileTo('p id="yes" class="no" Blork', '<p id="yes" class="no">Blork</p>');
  return shouldCompileTo('p id="yes" class="no" One <b>asd</b>!', '<p id="yes" class="no">One <b>asd</b>!</p>');
});

test("nesting", function() {
  var emblem;
  emblem = "p class=\"hello\" data-foo=\"gnarly\"\n  span Yes";
  return shouldCompileTo(emblem, '<p class="hello" data-foo="gnarly"><span>Yes</span></p>');
});

suite("html nested");

test("basic", function() {
  var emblem;
  emblem = "p\n  span Hello\n  strong Hi\ndiv\n  p Hooray";
  return shouldCompileTo(emblem, '<p><span>Hello</span><strong>Hi</strong></p><div><p>Hooray</p></div>');
});

test("empty nest", function() {
  var emblem;
  emblem = "p\n  span\n    strong\n      i";
  return shouldCompileTo(emblem, '<p><span><strong><i></i></strong></span></p>');
});

test("empty nest w/ attribute shorthand", function() {
  var emblem;
  emblem = "p.woo\n  span#yes\n    strong.no.yes\n      i";
  return shouldCompileTo(emblem, '<p class="woo"><span id="yes"><strong class="no yes"><i></i></strong></span></p>');
});

suite("mustache");

test("various one-liners", function() {
  var emblem;
  emblem = "= foo\narf\np = foo\nspan.foo\np data-foo=\"yes\" = goo";
  return shouldCompileTo(emblem, {
    foo: "ASD",
    arf: "QWE",
    goo: "WER"
  }, 'ASDQWE<p>ASD</p><span class="foo"></span><p data-foo="yes">WER</p>');
});

test("double =='s un-escape", function() {
  var emblem;
  emblem = "== foo\nfoo\np == foo";
  return shouldCompileTo(emblem, {
    foo: '<span>123</span>'
  }, '<span>123</span>&lt;span&gt;123&lt;/span&gt;<p><span>123</span></p>');
});

test("nested combo syntax", function() {
  var emblem;
  emblem = "ul = each items\n  = foo";
  return shouldCompileTo(emblem, {
    foo: '<span>123</span>'
  }, '<span>123</span>&lt;span&gt;123&lt;/span&gt;<p><span>123</span></p>');
});
